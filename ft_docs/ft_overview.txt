FileTasker
==========

FileTasker is a general-purpouse task-oriented ETL tool, written with modular extensability in mind.


Overview
========

FileTasker is split into modules.
Each module is responsible for implimenting a subset of operations a task can choose to call.

Most automated functions can be stubbed out and/or overridden in a task, or extended by overriding specific strategically placed hooks in existing functions.
This is as simple as declaring a new shell function with the same name as the old function or hook.

Core functionality is kept in ft_common_ops.
This includes helpful shell functions, such as array matching, task loading and validation, subtask selection, and execution of external tools.

The logging, tracing, and narration functionality is kept in ft_logging_core and ft_logging_ops.
In turn, this has it's own submodules: ft_logging_console for narration, ft_logging_files for tracing, and ft_logging_db for metainfo.

File based ETL is handled by the ft_file_core and ft_file_ops modules.
This also has it's own submodules: ft_file_compression, ft_file_matching, ft_file_hashing, and ft_file_signing.


Example
=======

In Filetasker, you declare a 'task', a list of simple repeatable instructions to perform an operation:

task() { make_log_header "${task_name} Working on ${file_name}";
  local MyTask_SourceFiles=( "control" "binary" "xml_source" ); file_ext=".dat";
  if is_not_in_array "${file_name%$file_ext}" "MyTask_SourceFiles"; then  # skip processing of this file.
    message_output ${MSG_NOTICE} "Skipped ${1}, Not a requested Source File"; return ${ERR_UNDEFINED_SOURCE}; fi  # Report this task iteration ended early and bail out.
 
  task_pre; ar_file_name=( "dataset" "${file_name%$file_ext}" "${ar_path_name[0]}" "dat" );  # Set up our $new_file_name
  build_filename; task_post;
}  # End of Task


Tasks can define as many pretasks or posttasks as needed, with as many or as few parameters as required.
This task sorts and renames three files from multiple /CCU_yyyymmdd/ directories into /yyyy/mm/dd/ directories,
 while skipping over the source files that are still being continuously written to. Only complete files will be processed.

task_pre() { match_take_snapshot ${file_name} # Take a snapshot of the file
  if [[ "$ft_multidir" -eq "1" ]]; then source_path="${source_base_path}${dir_name}/"; fi  # Define how multidir uses source paths
  parse_pathname ${dir_name}; parse_filename ${file_name};  # Parse the dated pathname into $ar_path_name & parse the . separated filename into $ar_file_name values
  parse_to_epoch_from_yyyymmdd_dir ${ar_path_name[0]#"CCU_"}; }  # Get the date from the directory the file was stored in.


The snapshot check ensures that live files currently being written to are skipped until the next full filetasker iteration.
They will be checked again and added to the archive in their complete form on the next filetasker run.

task_post() { if match_check_snapshot ${file_name}; then :; else return ${E_MISMATCH}; fi # Bail out early
  generate_yyyy_mm_dd_date_dir_from_epoch ${file_epoch};  # Dated Directory needs to be generated from the timestamp.
  target_path="${target_base_path}${date_dir}";  # Set the right dated target path (dirs always have trailing /)
  perform_fileop ${selected_subtask} ${orig_file_name} ${new_file_name}; }  # Perform the file operation (above takes care of all paths for us)


Some subtasks, like info or import, will ignore a new_file_name, or in some cases, only use the new_file_name, if the source file had already been moved by filetasker.
Here's an example of an overridden hook:

task_directory_complete() {  # Called automatically at the end of iterate_files()
  clean_source_dir ${1}; }  # Clean out the source directory by removing empty directories.


And some of the other default hooks you can override:

task_pre() { :; }  # Called manually from beginning of task()
task_post() { :; }  # Called manually at end of task()
task_subtask() { :; }  # Defined for special tasks
task() { :; }  # Called automatically by iterate_files()
task_directory_complete() { :; }  # Called once automatically at the end of iterate_files() loop, $PWD as $1
task_complete() { :; }  # Called once automatically at the end of iterate_directories(), No Inputs
task_multidir_pre() { :; }  # Called automatically before directory pop
task_multidir_info() { :; }  # Called automatically after directory pop, before iterate_files()
task_multidir_post() { :; }  # Called automatically after iterate_files() completes

Example Help Output
=================

Here's a simple 'ft_help' task definition, and it's output when ran.

task_subtasks=( help )
task_name="ft_help"
file_ext=".sh"
source_path="${script_path}/ft_tasks/"

task_init() {
        echo "    FT_Help Module - Listing known tasks..."
        return 0; }

task_help() {
        echo "    FT_Help Module - Found task ${1}"
        #if [[ "${1}" == "ft_help.sh" ]]; then return 127; else $PWD/${1}; return 0; fi
        $PWD/${1}; # Execute the module for help.
        return 0; }

task() {
    task_help $1
    local return_value=${?}
    if [[ $return_value != 0 ]]; then echo "     Failure. Reason ID: ${return_value}"; fi
    return 0; }

./filetasker.sh ft_help help

 FileTasker V0.7r24
   Loading Task: /home/kamilion/Git/filetasker/ft_tasks/ft_help.sh
   FileTasker Help Module Loaded at 0 seconds.
    FT_Help Module - Listing known tasks...
   Scanned 5 .sh files in /home/kamilion/Git/filetasker/ft_tasks/
    FT_Help Module - Found task aces.sh
   Supported Subtasks in aces.sh: debug link copy move
    FT_Help Module - Found task center.sh
   Supported Subtasks in center.sh: debug link copy move
    FT_Help Module - Found task ft_help.sh
   Supported Subtasks in ft_help.sh: help
    FT_Help Module - Found task ldm-all.sh
   Supported Subtasks in ldm-all.sh: chain
    FT_Help Module - Found task ldm.sh
   Supported Subtasks in ldm.sh: debug link copy move
   Completed operations on 0 of 5 .sh files in /home/kamilion/Git/filetasker/ft_tasks/ at 0 seconds.


Hypnotic Feature List
=====================

Filetasker has several helpful automated functions that make your quest for ETL easier.
Filetasker can generate directories with symlinks to recently processed files, for importing them as BLOBs into a database of your choice.
Filetasker can automatically use SHA family hashing & GPG sign files before and/or after compressing them with any common UNIX compressor.
Filetasker can call additional tasks, external tools, generate new configurations for them, and parse their output.
Filetasker uses the high performance SQLite3 database internally to store and allow easy standards-based SQL89 access to it's metadata library.
Filetasker can export it's metadata library into common CSV, pipe delimeted, or full SQL INSERT statements with image thumbnails and inline BLOBs.
Filetasker keeps it's metadata stored with your data to make individual backup and recovery of fine-grained datasets easier.
Filetasker can be used for offline replication using secure industry standard SSH and RSYNC technology.
Filetasker can interact directly with your database, as long as there is an available SQL89-compliant commandline interface.
Filetasker supports metadata extraction from the HDF5 and NetCDF formats, as well as plaintext data.
Filetasker tasks can be taught to inspect the contents of binary files for metadata discovery, if such inspection tools are available.
Filetasker is built on common unix tools, such as the Bash shell, SQLite3 database, and the GNU coreutils for run-anywhere support.
Filetasker supports 32bit and 64bit versions of Linux, BSD-derivatives, Apple OSX, Sun Solaris and POSIX-compliant Microsoft Windows installations.
Filetasker is well commented code. Over 30% of lines are comments, and most of the logging calls act as verbose comments as well.
Filetasker supports explicitly serial operations, and explicitly parallel operations with ease!
Filetasker function calls are verbosly named, so you don't have to guess what ft_filematch_take_snapshot() and ft_filematch_check_snapshot() are doing.
Filetasker supports subtasks: symlinking, copying, or moving target files, without having to rewrite your task body.
Filetasker supports intelligent overwrites: Links are updated, copy will overwrite a link but not a file, and a move will overwrite a link or a file.
Filetasker commandlines are short and unambiguous, meant for use by other automata like cron, at, or a webservice CGI call.
Filetasker supports severity-based realtime logging to sqlite database files, so even a webservice reading them can display various levels of realtime status data.
Filetasker uses 64-bit unix epoch timestamps to unambiguously identify a specific UTC second between January 1, 1970 and December 31st, 9999.



PRIVATE: Needs work
===================

change references from 'loud' to 'verbose' on ft_config scripts
need good text search function
need local gpg static executable for hashing and signing
need gpg wrapper functions for hashing
need gpg wrapper functions for key generation
need gpg wrapper functions for signing

get rid of existing sqlite logger, it's abysmally slow due to the overhead of executing sqlite once per 'append'.
sqlite coproc needs bash4. need it for associative arrays too. Can do amazing things in little code with these.
sqlite coproc means only one running copy of sqlite and redirecting I/O to it's console and getting results back
sqlite coproc is WAY FASTER than old file appends & allows parallel operations like hash + sign + match concurrently.
Not much other code needs to change to take advantage of this, as it's already been planned and prepared for.
need local bash4 static executable (including windows, muahaha)
need local sqlite3 static executable
need bash4 wrappers for scooping stdout into associative arrays
need sqlite wrappers for load & store of associative arrays as transactions

Need bash4 for using sqlite as a coproc:
http://www.bash-hackers.org/wiki/doku.php/syntax/keywords/coproc
Also need bash4 for 'mapfile' and associative arrays.
http://www.bash-hackers.org/wiki/doku.php/bash4
http://tiswww.case.edu/php/chet/bash/CHANGES

fixup ft_config platform scripts to use different static executables.
need coproc setup code (have working examples already)
USE SQLITE IN MEMORY DATABASE FOR STUFF
Need a ft_tick() function called after each task() for sqlite coproc.
ft_tick will open and close sqlite transactions, to allow filetasker to be stopped and restarted.
traps need update for transaction abort & coproc closeout.
need sqlite wrapper functions for gpg hash & sign goodies

need sqlplus cli export support wrapper (ORACLE)
need mysql cli export support wrapper
need postgresql cli export support wrapper
need sqlite triggers for timestamps (ft_note already does this)

need better configuration system -- propose ft-tool.sh frontend, db or configfile backed, prefixed variable system with per-task load/store.
ft_tick() will update prefixed configuration from db on the fly. ft-tool.sh frontend can flip configuration switches while filetasker is running.
use existing ft_note in git as basis for ft-tool.

need to tag all ft-exported functions with ft_$moduleshortname so tasks have their entire namespace.
need to build a module loader so tasks choose which modules are automatically loaded by an early array declare inside task.
need wrappers for h5dump and ncdump
